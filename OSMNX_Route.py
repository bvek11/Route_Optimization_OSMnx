# -*- coding: utf-8 -*-
"""OSMNX_Study (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y6K7rfYlK1tYwJbaGOOc8vhyql9_tDI0
"""

pip install osmnx

!pip install googlemaps

import osmnx as ox
import pandas as pd
import geopandas as gpd
import networkx as nx
import googlemaps
from shapely.geometry import Point
import matplotlib.pyplot as plt

!pip install networkx

!pip install googlemaps

!pip install osmnx

# Specify the city and state
state = "Tamil Nadu"

# Retrieve road network for Thiruvananthapuram
G = ox.graph_from_place(f"{state}", network_type='all')

# Visualize thea road network
ox.plot_graph(G, bgcolor="w", node_color="r", edge_color="#aaa", figsize=(12,12))
G.to_file(r"/content/drive/MyDrive/osm.shp")

G.to_file(r"/content/drive/MyDrive/osm.shp")

from google.colab import drive
drive.mount('/content/drive')

print("node count:", len(G.nodes()))
print("edge count:", len(G.edges()))

# Convert the graph to a GeoDataFrame
gdf_edges, gdf_nodes = ox.graph_to_gdfs(G)

# Display the GeoDataFrame with edge attri
gdf_edges

gdf_nodes

import geopandas as gpd

# impute edge (driving) speeds and calculate edge traversal times
G = ox.add_edge_speeds(G)
G = ox.add_edge_travel_times(G)

# convert string address into geographical coordinates
def geocode_address(address, crs=4326):
    geocode = gpd.tools.geocode(address, provider='nominatim',
                user_agent="drive time demo").to_crs(crs)
    return (geocode.iloc[0].geometry.y, geocode.iloc[0].geometry.x)

# get origin and destination coordinates
origin_point = geocode_address("Palayam, Thiruvananthapuram")
destination_point = geocode_address("Vellayambalam, Thiruvananthapuram")

# get closes graph nodes to origin and destination
orig_node = ox.distance.nearest_nodes(G, origin_point[1], origin_point[0])
destination_node = ox.distance.nearest_nodes(G,
    destination_point[1], destination_point[0])

# find shortest path based on travel time
route = nx.shortest_path(G, orig_node, destination_node, weight='travel_time')

fig, ax = ox.plot_graph_route(G, route, node_size=0, figsize=(40,40))

edge_lengths = ox.utils_graph.get_route_edge_attributes(
    G, route, 'length')
total_route_length = sum(edge_lengths)
print("Total route length in km:", total_route_length/1000)

edge_travel_time = ox.utils_graph.get_route_edge_attributes(
    G, route, 'travel_time')
route_travel_time = sum(edge_travel_time)
print("Travel time in minutes:", route_travel_time/60)

# Specify the city and state
city = "Thiruvananthapuram"
state = "Kerala"

# Retrieve road network for Thiruvananthapuram with 'drive' network type
G = ox.graph_from_place(f"{city}, {state}", network_type='drive')

# Visualize the road network
ox.plot_graph(G, bgcolor="w", node_color="r", edge_color="#aaa", figsize=(12, 12))

# Impute edge (driving) speeds and calculate edge traversal times
G = ox.add_edge_speeds(G)
G = ox.add_edge_travel_times(G)

# Convert string address into geographical coordinates
def geocode_address(address, crs=4326):
    geocode = gpd.tools.geocode(address, provider='nominatim',
                user_agent="drive time demo").to_crs(crs)
    return (geocode.iloc[0].geometry.y, geocode.iloc[0].geometry.x)

# Get origin and destination coordinates
origin_point = geocode_address("Palayam, Thiruvananthapuram")
destination_point = geocode_address("Vellayambalam, Thiruvananthapuram")

# Get closest graph nodes to origin and destination
orig_node = ox.distance.nearest_nodes(G, origin_point[1], origin_point[0])
destination_node = ox.distance.nearest_nodes(G, destination_point[1], destination_point[0])

# Find shortest path based on travel time
route = nx.shortest_path(G, orig_node, destination_node, weight='travel_time')

# Visualize the shortest path on the road network
fig, ax = ox.plot_graph_route(G, route, node_size=0, figsize=(40, 40))

# Print route length and travel time
edge_lengths = ox.utils_graph.get_route_edge_attributes(G, route, 'length')
total_route_length = sum(edge_lengths)
print("Total route length in km:", total_route_length / 1000)

edge_travel_time = ox.utils_graph.get_route_edge_attributes(G, route, 'travel_time')
route_travel_time = sum(edge_travel_time)
print("Travel time in minutes:", route_travel_time / 60)

import pandas as pd

df=pd.read_csv(r"D:\Projects\Travel Companion\cleaned_tourist_data.csv")

df

top_rated_df = df[df['rating'] > 4.8]

# Display the new DataFrame
top_rated_df

import geopy.distance

# Find the latitude and longitude of the "Kovalam beach"
start_lat = top_rated_df.loc[top_rated_df['Places'] == 'Kovalam beach', 'Latitude'].values[0]
start_lon = top_rated_df.loc[top_rated_df['Places'] == 'Kovalam beach', 'Longitude'].values[0]

# Function to calculate distance between two coordinates using Haversine formula
def calculate_distance(start_coord, end_coord):
    return geopy.distance.distance(start_coord, end_coord).kilometers

# Calculate distances from the starting location to each destination
distances = []
for index, row in top_rated_df.iterrows():
    end_coord = (row['Latitude'], row['Longitude'])
    distance = calculate_distance((start_lat, start_lon), end_coord)
    distances.append(distance)

# Add distances to the DataFrame
top_rated_df['Distance_from_Kovalam'] = distances

# Display the DataFrame with distances
top_rated_df

